[Оглавление](README.md)

# 10. Cold stream and Hot stream

Observable последовательности бывают двух видов, называемых «горячими» и «холодными», которые имеют важные различия. В этой главе мы объясним, что представляет собой каждый тип.

### 10.1. Cold stream

Холодные наблюдаемые — это наблюдаемые, которые запускают свою последовательность, только тогда когда у последовательности имеется хотя бы один подписчик.

Примером “холодного” потока будет`Observable.interval`. Независимо от того, когда он создан и когда на него подписана, он будет генерировать одну и ту же последовательность для каждого подписчика.

```
Observable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS);
		
cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
cold.subscribe(i -> System.out.println("Second: " + i));

// Output
// First: 0
// First: 1
// First: 2
// Second: 0
// First: 3
// Second: 1
// First: 4
// Second: 2
// ...
```

Два подписчика не получают одно и то же значение одновременно, даже если они оба подписаны на один и тот же observable объект. Они видят одну и ту же последовательность, за исключением того, что каждый видит, начало, когда они подписались.

Примеры кода, которые мы видели в этом руководстве до сих пор, были “холодными” observable. Каждый observable, созданный с помощью `Observable.create`, является “холодным” observable. Это же относиться к операторам `just`, `range`,`timer`,`from`

“Холодные” observable необязательно представляют одну и ту же последовательность каждому подписчику. Если, например, observable объект подключается к базе данных и выдает результаты запроса, фактическое значение будет зависеть от состояния базы данных на момент подписки. Тот факт, что подписчик получит весь запрос с самого начала, делает этот observable “холодным”.

### 10.2. Hot stream

Горячие observable выдают значения, независимые от отдельных подписок. У них есть своя временная шкала, и события происходят вне зависимости от того, слушает их кто-то или нет. Примером являются нажатия на кнопки внутри Android-приложения. Кнопка генерирует события независимо от того, слушает ли их кто-то. Когда подписка оформлена, наблюдатель получает текущие события по мере их возникновения. Вы не получаете и не хотите получать отчет обо всем, что сделала кнопка с момента загрузки системы. Когда вы отказываетесь от подписки, это также не мешает вашей кнопке генерировать события. Вы просто их не получаете. Если вы подпишетесь повторно, вы снова увидите текущие события без повторения того, что вы пропустили.

### 10.3. publish()

Существуют способы преобразования холодных observable в горячие и наоборот. Холодные observable становятся горячими вместе с `publish()`оператором.

```
public final ConnectableObservable<T> publish()
```

`publish`возвращает `ConnectableObservable<T>`, который является расширением `Observable<T>`с тремя дополнительными методами

```
1. public final Subscription connect()
2. public abstract void connect(Action1<? super Subscription> connection)
3. public Observable<T> refCount()
```

Еще существует один вариант `publish()` с селектором, преобразующий последовательность перед ее публикацией.

```
public final <R> Observable<R> publish(Func1<? super Observable<T>,? extends Observable<R>> selector)
```

Они `selector` могут делать все, что мы научились делать с наблюдаемыми. Полезность этого заключается в том, что для селектора делается одна подписка, которую можно использовать повторно столько раз, сколько необходимо. Без этой перегрузки повторное использование наблюдаемого может привести к множеству подписок. Невозможно гарантировать, что подписки будут происходить в одно и то же время и, следовательно, будут отображаться в одной и той же последовательности.

Этот метод возвращает `Observable<T>` вместо `ConnectableObservable<T>`, поэтому функциональность подключения, которую мы собираемся обсудить, здесь не применяется.

### 10.3. connect()

Первоначально `ConnectableObservable`он ничего не излучает. При вызове `connect`он создаст новую подписку на свой исходный наблюдаемый объект (тот, который мы вызвали `publish`). Он начнет получать события и отправлять их своим подписчикам. Все подписчики будут получать одни и те же события одновременно

```
ConnectableObservable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS).publish();
cold.connect();

cold.subscribe(i -> System.out.println("First: " + i));
Thread.sleep(500);
cold.subscribe(i -> System.out.println("Second: " + i));

// output
// First: 0
// First: 1
// First: 2
// Second: 2
// First: 3
// Second: 3
// First: 4
// Second: 4
// First: 5
// Second: 5
```

Поскольку `connect` возвращает Disposable, для того чтобы отписаться, необходимо вызвать просто метод dispose().

### 10.4 ****refCount()****

Для преобразования hot stream в cold stream необходимо вызваться функцию `refCount`

```
Observable<Long> cold = Observable.interval(200, TimeUnit.MILLISECONDS).publish().refCount();
```

### 10.5 replay()

```
public final ConnectableObservable<T> replay()
```

`replay`напоминает `ReplaySubject`. После подключения он начнет собирать значения. Как только новый наблюдатель подпишется на наблюдаемую, будут воспроизведены все собранные значения. Как только он догонит, он будет получать значения параллельно всем остальным наблюдателям.
[Оглавление](README.md)

# 8. Типы планировщиков

RxJava предоставляет высокоуровневый API для работы с многопоточность. Для реализации существует разнообразное количество планировщиков. Планировщики - это реализация ThreadPool.
Существует 5 стандартных реализаций планировщиков:

1. *single()*
2. *newThread()*
3. *computation()*
4. *io()*
5. *trampoline()*

## 8.1. single()

Такой планировщик можно рассматривать, если вам необходимо выполнить всю работу последовательно в одном потоке. Такой тип планировщика может быть полезен если необходимо выполнить потоконебезопасный код в отдельном потоке.

## 8.2. newThread()

Создаёт новый поток для каждого активного Observable, не пытаясь переиспользовать ранее созданные потоки. Важно понимать, что в сложных задачах количество созданных threads не ограничено, и можно “уронить” приложение из-за нехватки памяти.

## 8.3. computation()

Этот вид планировщика используется для математических вычислений. Такой тип планировщика удобен тем, что создает количество потоков, соответствующее числу ядер в процессоре для параллельной обработки. Если вы не знаете какой тип планировщика вам подходит, то можете использовать Schedulers.computation() в качестве дефолтного. Многие операторы RxJava используют по умолчанию как раз Schedulers.computation()

## 8.4. io()

Наиболее распространенный вид scheduler’a. Этот тип используется для сетевых запросов, операций чтения данных из файла, записи или чтения данных из БД. Такой планировщик создаёт необходимое количество потоков для эффективного выполнения вашей задачи, удаляет ненужные, и старается переиспользовать потоки, которые могут понадобиться. Важно понимать, что количество созданных потоков не ограничено, соответственно есть опасность создания большого количества потоков и нехватки памяти. Неиспользуемый threads (потоки) очищаются после 60 секунд не активности.

## 8.5. trampoline()

Выполняет код в текущем потоке, используется для последовательного выполнения задач.

**ExecutorService**

Если вдруг из выше перечисленных планировщиков нам не подошел никакой, то можно создать свой собственный планировщик.

```kotlin
val executor: ExecutorService = Executors.newFixedThreadPool(numberOfThreads)
val scheduler: Scheduler = Schedulers.from(executor)

Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")
          .subscribeOn(scheduler)
          .doFinally(executor::shutdown)
          .subscribe(System.out::println);
```

## 8.6 Schedulers.start() и Schedulers.shotdown()

Данные методы используются соответсвенно для инициализации планировщика и его очищения. Метод Schedulers.shutdown() перестанет выполнять любые задачи и для того, чтобы код снова выполнялся на отдельном потоке, необходимо реинициализировать планировщик с помощью Schedulers.start()